# 回测系统详细说明文档

## 目录
1. [系统架构](#系统架构)
2. [初始化阶段](#初始化阶段)
3. [数据加载阶段](#数据加载阶段)
4. [回测执行阶段](#回测执行阶段)
5. [报告生成阶段](#报告生成阶段)
6. [结果可视化阶段](#结果可视化阶段)

---

## 系统架构

### 核心类结构

```
BacktestSystem (回测系统主类)
├── BacktestEngine (回测引擎)
│   ├── 账户状态管理
│   ├── 交易执行
│   └── 权益计算
└── Strategy (策略类，如TurtleStrategy)
    ├── 指标计算
    ├── 信号生成
    └── 风险管理
```

**代码位置：**
- `BacktestSystem` 类：`backtest_system.py` 第307-939行
- `BacktestEngine` 类：`backtest_system.py` 第30-304行
- `TurtleStrategy` 类：`strategies/turtle_strategy.py`

---

## 初始化阶段

### 步骤1：创建策略实例

**代码位置：** `backtest_system.py` 第896-911行（main函数）

```python
# 创建策略参数
strategy_params = {
    'n_entries': 3,          # 最大加仓次数
    'risk_ratio': 1.0,       # 风险比例（%）
    'atr_length': 20,        # ATR周期
    'bo_length': 20,         # 短周期突破（20日）
    'fs_length': 55,         # 长周期突破（55日）
    'te_length': 10,         # 移动止盈周期
    'use_filter': False,     # 是否使用上次盈利过滤
    'mas': 10,               # 短周期均线
    'mal': 20                # 长周期均线
}

# 创建策略实例
strategy = TurtleStrategy(strategy_params)
```

**说明：**
- 策略参数存储在 `strategy.params` 中
- 策略名称自动设置为类名（`TurtleStrategy`）

**对应代码：** `strategies/turtle_strategy.py` 第32-59行

---

### 步骤2：创建回测系统

**代码位置：** `backtest_system.py` 第312-328行

```python
# 创建回测系统
backtest = BacktestSystem(
    strategy=strategy,           # 策略实例
    initial_capital=10000,        # 初始资金
    leverage=5.0,                # 杠杆倍数
    position_ratio=0.5           # 仓位比例（50%）
)
```

**内部执行流程：**

#### 2.1 初始化BacktestSystem
**代码位置：** `backtest_system.py` 第312-329行

```python
def __init__(self, strategy, initial_capital=10000, leverage=5.0, position_ratio=0.5):
    self.strategy = strategy
    self.engine = BacktestEngine(...)  # 创建回测引擎
    self.data = None  # 数据初始为空
```

#### 2.2 初始化BacktestEngine
**代码位置：** `backtest_system.py` 第36-67行

```python
def __init__(self, initial_capital=10000, commission_rate=0.001, 
             leverage=5.0, position_ratio=0.5):
    # 基础参数
    self.initial_capital = initial_capital      # 初始资金：10000
    self.commission_rate = commission_rate      # 手续费率：0.1%
    self.leverage = leverage                    # 杠杆倍数：5倍
    self.position_ratio = position_ratio        # 仓位比例：0.5（50%）
    
    # 计算可用资金（考虑仓位比例）
    self.available_capital = initial_capital * position_ratio  # 5000
    
    # 账户状态初始化
    self.balance = self.available_capital       # 余额：5000
    self.equity = self.available_capital       # 权益：5000
    self.position_size = 0.0                   # 持仓数量：0
    self.position_value = 0.0                  # 持仓价值：0
    self.entry_price = 0.0                     # 入场价格：0
    self.entry_idx = -1                        # 入场索引：-1
    self.entry_count = 0                       # 加仓次数：0
    
    # 交易记录初始化
    self.trades = []                            # 交易记录列表
    self.equity_curve = []                      # 权益曲线
    self.signals = []                           # 信号记录
```

**关键计算：**
- `available_capital = initial_capital × position_ratio = 10000 × 0.5 = 5000`
- 只有 `available_capital` 用于交易，剩余资金保留

---

## 数据加载阶段

### 步骤3：加载历史数据

**代码位置：** `backtest_system.py` 第916-924行（main函数）

有两种数据加载方式：

#### 方式1：从CSV文件加载
**代码位置：** `backtest_system.py` 第331-375行

```python
backtest.load_data_from_csv(csv_file, symbol='ETHUSDT')
```

**执行流程：**

1. **读取CSV文件**
   ```python
   df = pd.read_csv(filepath)
   ```
   **代码位置：** 第339行

2. **筛选币种（如果指定）**
   ```python
   if 'symbol' in df.columns and symbol:
       symbol_variants = [symbol, symbol.replace('USDT', '/USDT'), ...]
       df_filtered = df[df['symbol'].isin(symbol_variants)]
   ```
   **代码位置：** 第342-350行

3. **处理时间索引**
   ```python
   if 'timestamp' in df.columns:
       df['timestamp'] = pd.to_datetime(df['timestamp'])
       df.set_index('timestamp', inplace=True)
   ```
   **代码位置：** 第353-360行

4. **验证必要列**
   ```python
   required_columns = ['open', 'high', 'low', 'close', 'volume']
   for col in required_columns:
       if col not in df.columns:
           raise ValueError(f"CSV文件缺少必要的列: {col}")
   ```
   **代码位置：** 第362-366行

5. **按时间排序**
   ```python
   df = df.sort_index()
   self.data = df
   ```
   **代码位置：** 第369-371行

#### 方式2：从币安API加载
**代码位置：** `backtest_system.py` 第377-441行

```python
backtest.load_data_from_binance('BTC/USDT', interval='1h', limit=2000)
```

**执行流程：**

1. **创建币安交易所实例**
   ```python
   exchange = ccxt.binance({
       'enableRateLimit': True,
       'options': {'defaultType': 'spot'}
   })
   ```
   **代码位置：** 第391-394行

2. **分页获取K线数据**
   ```python
   while len(all_klines) < limit:
       ohlcv = exchange.fetch_ohlcv(symbol, interval, ...)
       all_klines.extend(ohlcv)
   ```
   **代码位置：** 第400-420行

3. **转换为DataFrame**
   ```python
   df = pd.DataFrame(all_klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
   df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
   df.set_index('timestamp', inplace=True)
   ```
   **代码位置：** 第427-429行

4. **数据类型转换和排序**
   ```python
   for col in ['open', 'high', 'low', 'close', 'volume']:
       df[col] = df[col].astype(float)
   df = df.sort_index()
   ```
   **代码位置：** 第432-435行

**最终结果：**
- `self.data` 包含完整的OHLCV数据
- 数据按时间排序
- 索引为时间戳（DatetimeIndex）

---

## 回测执行阶段

### 步骤4：运行回测

**代码位置：** `backtest_system.py` 第927行（main函数）

```python
backtest.run_backtest(max_entries=3, risk_ratio=1.0)
```

**执行流程：**

#### 4.1 重置回测引擎
**代码位置：** `backtest_system.py` 第443-455行

```python
def run_backtest(self, max_entries=3, risk_ratio=1.0):
    if self.data is None:
        raise ValueError("请先加载数据")
    
    # 重置引擎
    self.engine.reset()
```

**reset()方法执行：**
**代码位置：** `backtest_system.py` 第69-81行

```python
def reset(self):
    # 重置账户状态
    self.balance = self.available_capital      # 余额重置为5000
    self.equity = self.available_capital      # 权益重置为5000
    self.position_size = 0.0                   # 持仓清零
    self.position_value = 0.0
    self.entry_price = 0.0
    self.entry_idx = -1
    self.entry_count = 0
    
    # 清空记录
    self.trades = []
    self.equity_curve = []
    self.signals = []
```

#### 4.2 初始化策略
**代码位置：** `backtest_system.py` 第457-458行

```python
# 初始化策略
self.strategy.initialize(self.data)
```

**策略初始化执行：**
**代码位置：** `strategies/turtle_strategy.py` 第77-101行

```python
def initialize(self, data: pd.DataFrame):
    # 1. 计算ATR（平均真实波幅）
    self.atr = calculate_atr(data['high'], data['low'], data['close'], self.atr_length)
    
    # 2. 计算20日唐奇安通道（延后1个周期，避免未来函数）
    self.donchian_hi = calculate_donchian_high(data['high'], self.bo_length, shift=1)
    self.donchian_lo = calculate_donchian_low(data['low'], self.bo_length, shift=1)
    
    # 3. 计算55日唐奇安通道（Failsafe，长周期突破）
    self.fs_donchian_hi = calculate_donchian_high(data['high'], self.fs_length, shift=1)
    self.fs_donchian_lo = calculate_donchian_low(data['low'], self.fs_length, shift=1)
    
    # 4. 计算移动止盈（10日最高/最低点）
    self.exit_lowest = calculate_donchian_low(data['low'], self.te_length, shift=1)
    self.exit_highest = calculate_donchian_high(data['high'], self.te_length, shift=1)
    
    # 5. 计算均线（用于退出信号）
    self.ma_short = calculate_sma(data['close'], self.mas)  # 10日均线
    self.ma_long = calculate_sma(data['close'], self.mal)    # 20日均线
```

**关键指标说明：**
- **ATR（Average True Range）**：衡量价格波动性，用于计算仓位大小和止损距离
- **唐奇安通道**：N日最高价和最低价，用于突破信号
- **移动止盈**：10日最高/最低点，用于移动止损
- **均线**：用于退出信号（均线交叉）

#### 4.3 遍历每个K线
**代码位置：** `backtest_system.py` 第465-563行

```python
# 遍历每个K线
for idx in range(len(self.data)):
    current_bar = self.data.iloc[idx]
    current_price = current_bar['close']
    
    # 步骤4.3.1：更新权益
    # 步骤4.3.2：检查止损
    # 步骤4.3.3：检查退出信号
    # 步骤4.3.4：检查加仓
    # 步骤4.3.5：检查入场信号
```

##### 步骤4.3.1：更新权益
**代码位置：** `backtest_system.py` 第470-471行

```python
# 更新权益（未实现盈亏）
self.engine.update_equity(current_price)
```

**update_equity()方法执行：**
**代码位置：** `backtest_system.py` 第282-304行

```python
def update_equity(self, current_price: float):
    if self.position_size == 0:
        # 无持仓：权益 = 余额
        self.equity = self.balance
    elif self.position_size > 0:  # 多头
        # 未实现盈亏 = (当前价 - 入场价) × 持仓数量
        unrealized_pnl = (current_price - self.entry_price) * self.position_size
        # 权益 = 余额 + 未实现盈亏
        self.equity = self.balance + unrealized_pnl
        self.position_value = self.position_size * current_price
    else:  # 空头
        size = abs(self.position_size)
        entry_price = self.entry_price
        # 未实现盈亏 = (入场价 - 当前价) × 持仓数量
        unrealized_pnl = (entry_price - current_price) * size
        self.equity = self.balance + unrealized_pnl
        self.position_value = size * current_price
    
    # 记录权益曲线
    self.equity_curve.append(self.equity)
```

**说明：**
- 权益 = 余额 + 未实现盈亏
- 每根K线都会记录权益值，用于绘制权益曲线

##### 步骤4.3.2：检查止损（移动止盈）
**代码位置：** `backtest_system.py` 第473-488行

```python
# 检查止损（移动止盈）
if self.engine.position_size != 0:
    stop_signal = self.strategy.check_stop_loss(
        self.data, idx, 
        self.engine.position_size, 
        self.engine.entry_price
    )
    if stop_signal:
        pnl = self.engine.close_position(
            stop_signal['price'], 
            idx, 
            stop_signal['reason']
        )
        if pnl is not None:
            self.strategy.update_trade_result(pnl)
        continue  # 平仓后跳过后续检查
```

**check_stop_loss()方法执行：**
**代码位置：** `strategies/turtle_strategy.py` 第253-297行

```python
def check_stop_loss(self, data, current_idx, position_size, last_entry_price):
    if current_idx < self.te_length:
        return None
    
    current_bar = data.iloc[current_idx]
    prev_idx = current_idx - 1
    
    # 获取10日最高/最低点（使用前一根K线的值，避免未来函数）
    exit_lowest = self.exit_lowest.iloc[prev_idx]
    exit_highest = self.exit_highest.iloc[prev_idx]
    
    # 多头止损：价格跌破10日最低点
    if position_size > 0:
        if current_bar['low'] < exit_lowest:
            return {
                'signal': 'close_long',
                'price': exit_lowest,  # 以10日最低点平仓
                'reason': '移动止盈（跌破10日最低点）'
            }
    
    # 空头止损：价格涨破10日最高点
    elif position_size < 0:
        if current_bar['high'] > exit_highest:
            return {
                'signal': 'close_short',
                'price': exit_highest,  # 以10日最高点平仓
                'reason': '移动止盈（涨破10日最高点）'
            }
    
    return None
```

**说明：**
- 移动止盈：随着价格上涨（多头）或下跌（空头），止损点也会移动
- 多头：止损点跟随10日最低点上升
- 空头：止损点跟随10日最高点下降

##### 步骤4.3.3：检查均线交叉退出
**代码位置：** `backtest_system.py` 第490-497行

```python
# 检查均线交叉退出
if self.engine.position_size != 0:
    signal = self.strategy.generate_signals(self.data, idx, self.engine.position_size)
    if signal['signal'] in ['close_long', 'close_short']:
        pnl = self.engine.close_position(current_price, idx, signal['reason'])
        if pnl is not None:
            self.strategy.update_trade_result(pnl)
        continue
```

**generate_signals()方法执行（退出部分）：**
**代码位置：** `strategies/turtle_strategy.py` 第139-170行

```python
# 检测均线交叉
crossunder = detect_crossunder(self.ma_short, self.ma_long)  # 死叉
crossover = detect_crossover(self.ma_short, self.ma_long)    # 金叉

# 检查退出信号（均线交叉）
if crossunder.iloc[current_idx] and position_size > 0:
    # 多头：短均线下穿长均线（死叉）→ 退出
    return {
        'signal': 'close_long',
        'price': current_bar['close'],
        'reason': '均线死叉退出'
    }

if crossover.iloc[current_idx] and position_size < 0:
    # 空头：短均线上穿长均线（金叉）→ 退出
    return {
        'signal': 'close_short',
        'price': current_bar['close'],
        'reason': '均线金叉退出'
    }
```

**说明：**
- 均线交叉作为趋势反转信号
- 多头持仓：死叉时退出
- 空头持仓：金叉时退出

##### 步骤4.3.4：检查加仓
**代码位置：** `backtest_system.py` 第499-523行

```python
# 检查加仓
if self.engine.position_size != 0 and self.engine.entry_count < max_entries:
    add_signal = self.strategy.check_add_position(
        self.data, idx,
        self.engine.position_size,
        self.engine.entry_price
    )
    if add_signal:
        # 计算加仓数量（使用相同的风险比例）
        atr_value = self.strategy.atr.iloc[idx]
        if not pd.isna(atr_value) and atr_value > 0:
            add_size = self.strategy.get_position_size(
                self.engine.equity,  # 使用当前权益计算
                risk_ratio,
                atr_value,
                add_signal['price']
            )
            self.engine.add_position(
                add_signal['signal'],
                add_signal['price'],
                add_size,
                idx,
                add_signal['reason']
            )
        continue
```

**check_add_position()方法执行：**
**代码位置：** `strategies/turtle_strategy.py` 第208-251行

```python
def check_add_position(self, data, current_idx, position_size, last_entry_price):
    if current_idx < self.atr_length:
        return None
    
    atr_value = self.atr.iloc[current_idx]
    current_bar = data.iloc[current_idx]
    
    # 多头加仓：价格上涨0.5N（N = ATR）
    if position_size > 0:
        add_price = last_entry_price + 0.5 * atr_value
        if current_bar['high'] >= add_price:
            return {
                'signal': 'add_long',
                'price': add_price,
                'reason': f'多头加仓（价格达到{add_price:.4f}）'
            }
    
    # 空头加仓：价格下跌0.5N
    elif position_size < 0:
        add_price = last_entry_price - 0.5 * atr_value
        if current_bar['low'] <= add_price:
            return {
                'signal': 'add_short',
                'price': add_price,
                'reason': f'空头加仓（价格达到{add_price:.4f}）'
            }
    
    return None
```

**get_position_size()方法执行：**
**代码位置：** `strategies/base_strategy.py` 第51-68行

```python
def get_position_size(self, account_balance, risk_ratio, atr, entry_price):
    # 风险金额 = 账户余额 × 风险比例
    risk_amount = account_balance * (risk_ratio / 100)
    
    # 止损距离 = 2倍ATR
    stop_loss_distance = atr * 2
    
    # 仓位大小 = 风险金额 / 止损距离
    position_size = risk_amount / stop_loss_distance
    return position_size
```

**add_position()方法执行：**
**代码位置：** `backtest_system.py` 第144-203行

```python
def add_position(self, signal, price, size, current_idx, reason=""):
    if signal == 'add_long' and self.position_size > 0:
        # 计算新的平均入场价格
        total_size = self.position_size + size
        total_cost = self.position_size * self.entry_price + size * price
        self.entry_price = total_cost / total_size  # 加权平均
        
        self.position_size = total_size
        self.entry_count += 1
        
        # 计算成本（考虑杠杆）
        position_value = size * price
        margin = position_value / self.leverage
        cost = margin * (1 + self.commission_rate)  # 保证金 + 开仓手续费
        self.balance -= cost
        
        # 记录交易
        self.trades.append({
            'type': 'add_long',
            'price': price,
            'size': size,
            'idx': current_idx,
            'balance': self.balance,
            'equity': self.equity,
            'reason': reason
        })
```

**关键计算：**
- **平均入场价** = (原持仓数量 × 原入场价 + 加仓数量 × 加仓价) / 总持仓数量
- **保证金** = 加仓价值 / 杠杆倍数
- **成本** = 保证金 × (1 + 手续费率)
- **余额变化** = 余额 - 成本

##### 步骤4.3.5：检查入场信号
**代码位置：** `backtest_system.py` 第525-563行

```python
# 检查入场信号（只在无持仓时）
if self.engine.position_size == 0:
    signal = self.strategy.generate_signals(self.data, idx, 0)
    
    if signal['signal'] == 'long':
        # 计算仓位大小
        atr_value = self.strategy.atr.iloc[idx]
        if not pd.isna(atr_value) and atr_value > 0:
            position_size = self.strategy.get_position_size(
                self.engine.equity,
                risk_ratio,
                atr_value,
                signal['price']
            )
            self.engine.open_position(
                'long',
                signal['price'],
                position_size,
                idx,
                signal['reason']
            )
    
    elif signal['signal'] == 'short':
        # 类似做多逻辑
        ...
```

**generate_signals()方法执行（入场部分）：**
**代码位置：** `strategies/turtle_strategy.py` 第103-206行

```python
def generate_signals(self, data, current_idx, position_size=0):
    # 检查数据是否足够
    if current_idx < max(self.atr_length, self.fs_length, self.mal):
        return {'signal': 'hold', 'price': data.iloc[current_idx]['close'], 'reason': '数据不足'}
    
    current_bar = data.iloc[current_idx]
    prev_idx = current_idx - 1
    
    # 获取指标值（使用前一根K线的值，避免未来函数）
    atr_value = self.atr.iloc[current_idx]
    donchian_hi = self.donchian_hi.iloc[prev_idx]  # 20日最高点
    donchian_lo = self.donchian_lo.iloc[prev_idx]  # 20日最低点
    fs_donchian_hi = self.fs_donchian_hi.iloc[prev_idx]  # 55日最高点
    fs_donchian_lo = self.fs_donchian_lo.iloc[prev_idx]  # 55日最低点
    
    # 判断是否允许突破（过滤条件）
    allow_breakout = not self.use_filter or self.last_trade_loss
    
    # 入场信号
    long_entry = allow_breakout and current_bar['high'] > donchian_hi  # 20日突破做多
    short_entry = allow_breakout and current_bar['low'] < donchian_lo   # 20日突破做空
    
    # 长周期突破（Failsafe）- 只在无持仓时触发
    long_entry_fs = (position_size == 0) and current_bar['high'] > fs_donchian_hi  # 55日突破做多
    short_entry_fs = (position_size == 0) and current_bar['low'] < fs_donchian_lo  # 55日突破做空
    
    # 返回信号（优先级：退出 > 入场）
    if position_size == 0:
        if long_entry:
            return {
                'signal': 'long',
                'price': donchian_hi,  # 以20日最高点入场
                'reason': '20日通道突破做多'
            }
        
        if short_entry:
            return {
                'signal': 'short',
                'price': donchian_lo,  # 以20日最低点入场
                'reason': '20日通道突破做空'
            }
        
        if long_entry_fs:
            return {
                'signal': 'long',
                'price': fs_donchian_hi,  # 以55日最高点入场
                'reason': '55日通道突破做多（Failsafe）'
            }
        
        if short_entry_fs:
            return {
                'signal': 'short',
                'price': fs_donchian_lo,  # 以55日最低点入场
                'reason': '55日通道突破做空（Failsafe）'
            }
    
    return {'signal': 'hold', 'price': current_bar['close'], 'reason': '无信号'}
```

**open_position()方法执行：**
**代码位置：** `backtest_system.py` 第83-142行

```python
def open_position(self, signal, price, size, current_idx, reason=""):
    if signal == 'long':
        # 设置持仓信息
        self.position_size = size
        self.entry_price = price
        self.entry_idx = current_idx
        self.entry_count = 1
        
        # 计算成本（考虑杠杆）
        position_value = size * price              # 开仓价值
        margin = position_value / self.leverage   # 保证金
        cost = margin * (1 + self.commission_rate)  # 成本 = 保证金 + 开仓手续费
        self.balance -= cost
        
        # 记录交易
        self.trades.append({
            'type': 'open_long',
            'price': price,
            'size': size,
            'idx': current_idx,
            'balance': self.balance,
            'equity': self.equity,
            'reason': reason
        })
    
    elif signal == 'short':
        # 类似做多逻辑，但position_size为负数
        self.position_size = -size
        ...
```

**关键计算：**
- **开仓价值** = 数量 × 价格
- **保证金** = 开仓价值 / 杠杆倍数
- **成本** = 保证金 × (1 + 手续费率)
- **余额变化** = 余额 - 成本

#### 4.4 最后平仓（如果有持仓）
**代码位置：** `backtest_system.py` 第565-570行

```python
# 最后平仓（如果有持仓）
if self.engine.position_size != 0:
    last_price = self.data.iloc[-1]['close']
    pnl = self.engine.close_position(last_price, len(self.data) - 1, "回测结束平仓")
    if pnl is not None:
        self.strategy.update_trade_result(pnl)
```

#### 4.5 计算最终权益和收益率
**代码位置：** `backtest_system.py` 第572-587行

```python
# 计算最终权益
# 交易账户权益（只包含投入交易的部分）
trading_equity = self.engine.equity if self.engine.position_size != 0 else self.engine.balance

# 最终总资产 = 交易账户权益 + 未投入资金
final_equity = trading_equity + (self.engine.initial_capital - self.engine.available_capital)

# 收益率计算：用总资产变化除以初始资金
total_return = (final_equity - self.engine.initial_capital) / self.engine.initial_capital * 100
```

**关键计算：**
- **交易账户权益** = 最终余额（如果无持仓）或 最终权益（如果有持仓）
- **最终总资产** = 交易账户权益 + 未投入资金
- **总收益率** = (最终总资产 - 初始资金) / 初始资金 × 100

**示例：**
- 初始资金：10000
- 可用资金：5000（50%）
- 交易账户最终权益：9156.12
- 最终总资产：9156.12 + 5000 = 14156.12
- 总收益率：(14156.12 - 10000) / 10000 × 100 = 41.56%

---

### 步骤5：平仓操作详解

**close_position()方法执行：**
**代码位置：** `backtest_system.py` 第205-280行

#### 5.1 计算盈亏

**多头平仓：**
```python
if self.position_size > 0:  # 平多
    # 毛盈亏 = (平仓价 - 入场价) × 持仓数量
    gross_pnl = (price - self.entry_price) * self.position_size
    
    # 计算保证金和手续费
    size = self.position_size
    entry_margin = (self.entry_price * size) / self.leverage  # 入场时的保证金
    close_cost = (size * price) * self.commission_rate       # 平仓手续费
    open_cost = entry_margin * self.commission_rate          # 开仓手续费
    
    # 净盈亏 = 毛盈亏 - 平仓手续费 - 开仓手续费
    pnl = gross_pnl - close_cost - open_cost
    
    # 余额计算：收回保证金 + 毛盈亏 - 平仓手续费
    # 注意：开仓手续费已在开仓时扣除，所以这里不再扣除
    self.balance += entry_margin + gross_pnl - close_cost
```

**空头平仓：**
```python
else:  # 平空
    size = abs(self.position_size)
    entry_price = self.entry_price
    
    # 毛盈亏 = (入场价 - 平仓价) × 持仓数量
    gross_pnl = (entry_price - price) * size
    
    # 计算保证金和手续费
    entry_margin = (entry_price * size) / self.leverage
    close_cost = (size * price) * self.commission_rate
    open_cost = entry_margin * self.commission_rate
    
    # 净盈亏 = 毛盈亏 - 平仓手续费 - 开仓手续费
    pnl = gross_pnl - close_cost - open_cost
    
    # 余额计算
    self.balance += entry_margin + gross_pnl - close_cost
```

#### 5.2 记录交易
```python
self.trades.append({
    'type': trade_type,           # 'close_long' 或 'close_short'
    'price': price,               # 平仓价格
    'size': abs(self.position_size),  # 持仓数量
    'idx': current_idx,            # 当前索引
    'entry_price': saved_entry_price,  # 入场价格
    'pnl': pnl,                  # 净盈亏（已扣除所有手续费）
    'balance': self.balance,     # 余额
    'equity': self.balance,      # 权益（平仓后 = 余额）
    'reason': reason,            # 平仓原因
    'entry_count': self.entry_count  # 加仓次数
})
```

#### 5.3 重置持仓
```python
self.position_size = 0.0
self.position_value = 0.0
self.entry_price = 0.0
self.entry_idx = -1
self.entry_count = 0
```

---

## 报告生成阶段

### 步骤6：生成回测报告

**代码位置：** `backtest_system.py` 第929行（main函数）

```python
backtest.print_report()
```

**执行流程：**

#### 6.1 生成报告数据
**代码位置：** `backtest_system.py` 第589-684行

```python
def generate_report(self) -> Dict:
    # 提取所有平仓交易
    closed_trades = [t for t in self.engine.trades if 'close' in t['type']]
    
    # 计算最终权益
    trading_equity = self.engine.equity if self.engine.position_size != 0 else self.engine.balance
    final_equity = trading_equity + (self.engine.initial_capital - self.engine.available_capital)
    total_return = (final_equity - self.engine.initial_capital) / self.engine.initial_capital * 100
    
    # 计算统计指标
    pnls = [t['pnl'] for t in closed_trades]
    winning_trades = [p for p in pnls if p > 0]
    losing_trades = [p for p in pnls if p < 0]
    
    total_pnl = trading_equity - self.engine.available_capital  # 净盈亏
    
    win_rate = len(winning_trades) / len(closed_trades) * 100
    avg_win = np.mean(winning_trades) if winning_trades else 0
    avg_loss = np.mean(losing_trades) if losing_trades else 0
    profit_factor = abs(sum(winning_trades) / sum(losing_trades)) if losing_trades and sum(losing_trades) != 0 else (float('inf') if winning_trades else 0)
    
    # 计算最大回撤
    equity_array = np.array(self.engine.equity_curve)
    peak = equity_array[0]
    max_drawdown = 0
    max_drawdown_pct = 0
    
    for equity in equity_array:
        if equity > peak:
            peak = equity
        drawdown = peak - equity
        drawdown_pct = drawdown / self.engine.initial_capital
        max_drawdown = max(max_drawdown, drawdown)
        max_drawdown_pct = max(max_drawdown_pct, drawdown_pct)
    
    max_drawdown_pct = max_drawdown_pct * 100
    
    # 计算夏普比率
    sharpe_ratio = self._calculate_sharpe_ratio()
    
    return {
        'initial_capital': self.engine.initial_capital,
        'available_capital': self.engine.available_capital,
        'leverage': self.engine.leverage,
        'position_ratio': self.engine.position_ratio,
        'final_equity': final_equity,
        'total_return': total_return,
        'total_pnl': total_pnl,
        'total_trades': len(closed_trades),
        'winning_trades': len(winning_trades),
        'losing_trades': len(losing_trades),
        'win_rate': win_rate,
        'avg_win': avg_win,
        'avg_loss': avg_loss,
        'profit_factor': profit_factor,
        'max_drawdown': max_drawdown,
        'max_drawdown_pct': max_drawdown_pct,
        'sharpe_ratio': sharpe_ratio,
    }
```

#### 6.2 打印报告
**代码位置：** `backtest_system.py` 第856-893行

```python
def print_report(self):
    report = self.generate_report()
    
    print("\n" + "=" * 60)
    print("回测报告")
    print("=" * 60)
    print(f"初始资金: {report['initial_capital']:,.2f}")
    print(f"可用资金: {report['available_capital']:,.2f} (仓位比例: {report['position_ratio']*100:.1f}%)")
    print(f"杠杆倍数: {report['leverage']}x")
    print(f"最终权益: {report['final_equity']:,.2f}")
    print(f"总收益率: {report['total_return']:.2f}%")
    print(f"总交易次数: {report['total_trades']}")
    print(f"盈利交易: {report['winning_trades']}")
    print(f"胜率: {report['win_rate']:.1f}%")
    
    print(f"\n风险指标:")
    print(f"  最大回撤: {report['max_drawdown']:,.2f}")
    print(f"  最大回撤百分比: {report['max_drawdown_pct']:.2f}%")
    print(f"  盈亏比: {report['profit_factor']:.2f}")
    print(f"  夏普比率: {report['sharpe_ratio']:.2f}")
    print(f"  平均盈利: {report['avg_win']:.2f}")
    print(f"  平均亏损: {report['avg_loss']:.2f}")
    print("=" * 60)
    
    # 自动导出交易记录
    self.export_trades_to_csv()
```

#### 6.3 导出交易记录到CSV
**代码位置：** `backtest_system.py` 第802-854行

```python
def export_trades_to_csv(self, filepath=None):
    if not self.engine.trades:
        print("没有交易记录可导出")
        return
    
    # 准备交易记录数据
    trades_data = []
    for trade in self.engine.trades:
        trade_record = {
            '交易类型': trade['type'],
            '时间索引': trade['idx'],
            '时间': self.data.index[trade['idx']],
            '价格': trade['price'],
            '数量': trade['size'],
            '原因': trade.get('reason', ''),
        }
        
        # 如果是平仓交易，添加盈亏信息
        if 'close' in trade['type']:
            trade_record['入场价格'] = trade.get('entry_price', 'N/A')
            trade_record['盈亏'] = trade.get('pnl', 0)  # 净盈亏（已扣除所有手续费）
            trade_record['加仓次数'] = trade.get('entry_count', 0)
        
        trade_record['余额'] = trade.get('balance', 0)
        trade_record['权益'] = trade.get('equity', trade.get('balance', 0))
        
        trades_data.append(trade_record)
    
    # 转换为DataFrame并保存
    df = pd.DataFrame(trades_data)
    if filepath is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filepath = f"trades_{self.strategy.name}_{timestamp}.csv"
    
    df.to_csv(filepath, index=False, encoding='utf-8-sig')
    print(f"\n交易记录已保存到: {filepath}")
    print(f"共 {len(trades_data)} 笔交易记录")
    
    return filepath
```

---

## 结果可视化阶段

### 步骤7：绘制回测结果

**代码位置：** `backtest_system.py` 第933行（main函数）

```python
backtest.plot_results(save_path='backtest_result.png')
```

**执行流程：**
**代码位置：** `backtest_system.py` 第721-800行

```python
def plot_results(self, save_path=None):
    # 准备数据
    timestamps = self.data.index[:len(self.engine.equity_curve)]
    equities = self.engine.equity_curve
    
    # 计算收益率：相对于初始资金
    initial_equity = self.engine.available_capital
    returns = [(eq - initial_equity) / self.engine.initial_capital * 100 for eq in equities]
    
    # 创建图表
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
    fig.suptitle(f'{self.strategy.name} 回测结果', fontsize=16, fontweight='bold')
    
    # 1. 权益曲线（资金曲线）
    ax1.plot(timestamps, equities, linewidth=1.5, color='blue', alpha=0.8, label='权益曲线')
    ax1.axhline(y=initial_equity, color='gray', linestyle='--', alpha=0.7, label='初始资金')
    ax1.set_title('权益曲线', fontsize=14, fontweight='bold')
    ax1.set_ylabel('权益 (USDT)', fontsize=12)
    ax1.legend(loc='best', fontsize=10)
    ax1.grid(True, alpha=0.3)
    
    # 2. 收益率曲线
    ax2.plot(timestamps, returns, linewidth=1.5, color='green', alpha=0.8, label='收益率')
    ax2.axhline(y=0, color='red', linestyle='--', alpha=0.7, label='零线')
    ax2.set_title('收益率曲线', fontsize=14, fontweight='bold')
    ax2.set_ylabel('收益率 (%)', fontsize=12)
    ax2.set_xlabel('时间', fontsize=12)
    ax2.legend(loc='best', fontsize=10)
    ax2.grid(True, alpha=0.3)
    
    # 格式化时间轴
    if len(timestamps) > 100:
        step = max(1, len(timestamps) // 10)
        for ax in [ax1, ax2]:
            ax.set_xticks(timestamps[::step])
            ax.tick_params(axis='x', rotation=45)
    else:
        for ax in [ax1, ax2]:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
            ax.tick_params(axis='x', rotation=45)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=200, bbox_inches='tight')
        print(f"回测结果图已保存到: {save_path}")
    
    plt.show(block=True)
```

---

## 关键概念说明

### 1. 账户状态

- **余额（balance）**：账户中的现金，不包括未实现盈亏
- **权益（equity）**：账户总价值 = 余额 + 未实现盈亏
- **持仓数量（position_size）**：正数=多头，负数=空头，0=无持仓

### 2. 手续费计算

- **开仓手续费**：在开仓时扣除，从余额中扣除
- **平仓手续费**：在平仓时扣除，从余额中扣除
- **净盈亏**：毛盈亏 - 开仓手续费 - 平仓手续费

### 3. 杠杆交易

- **保证金** = 开仓价值 / 杠杆倍数
- **成本** = 保证金 × (1 + 手续费率)
- 平仓时：收回保证金 + 盈亏 - 平仓手续费

### 4. 仓位比例

- **可用资金** = 初始资金 × 仓位比例
- **未投入资金** = 初始资金 - 可用资金
- **最终总资产** = 交易账户权益 + 未投入资金

### 5. 收益率计算

- **总收益率** = (最终总资产 - 初始资金) / 初始资金 × 100
- 考虑未投入资金，确保收益率计算准确

---

## 执行顺序总结

1. **初始化**：创建策略和回测系统
2. **加载数据**：从CSV或API获取历史数据
3. **重置引擎**：清空所有状态和记录
4. **初始化策略**：计算所有技术指标
5. **遍历K线**：
   - 更新权益
   - 检查止损
   - 检查退出信号
   - 检查加仓
   - 检查入场信号
6. **最后平仓**：如果有持仓，强制平仓
7. **计算收益**：计算最终权益和收益率
8. **生成报告**：统计所有指标
9. **导出CSV**：保存交易记录
10. **绘制图表**：可视化回测结果

---

## 注意事项

1. **未来函数**：所有指标都使用前一根K线的值，避免未来函数
2. **手续费**：开仓和平仓都考虑手续费，确保回测结果真实
3. **杠杆**：使用杠杆时，保证金计算需要考虑杠杆倍数
4. **仓位比例**：只有部分资金用于交易，收益率计算需要考虑总资产
5. **权益曲线**：每根K线都记录权益值，用于绘制曲线和计算回撤

---

## 代码文件结构

```
backtest_system.py          # 回测系统主文件
├── BacktestEngine          # 回测引擎类
│   ├── __init__()          # 初始化
│   ├── reset()             # 重置
│   ├── open_position()     # 开仓
│   ├── add_position()      # 加仓
│   ├── close_position()    # 平仓
│   └── update_equity()     # 更新权益
└── BacktestSystem          # 回测系统类
    ├── __init__()          # 初始化
    ├── load_data_from_csv()    # 从CSV加载数据
    ├── load_data_from_binance() # 从币安加载数据
    ├── run_backtest()      # 运行回测
    ├── generate_report()   # 生成报告
    ├── print_report()      # 打印报告
    ├── export_trades_to_csv() # 导出交易记录
    └── plot_results()      # 绘制结果

strategies/
├── base_strategy.py        # 策略基类
│   ├── get_position_size() # 计算仓位大小
│   └── generate_signals()  # 生成信号（抽象方法）
└── turtle_strategy.py      # 海龟策略
    ├── initialize()        # 初始化指标
    ├── generate_signals()  # 生成交易信号
    ├── check_add_position() # 检查加仓
    └── check_stop_loss()   # 检查止损
```

---

**文档生成时间：** 2024年
**版本：** 1.0

